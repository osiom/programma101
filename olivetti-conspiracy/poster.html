<!DOCTYPE html>
<html>
<head>
  <title>Cascading Village - Telegram Updates</title>
  <style>
  body {
      margin: 0;
      padding: 0;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      background-color: #ffffff;
      position: relative;
      overflow: hidden;
      height: 100vh;
      width: 100vw;
  }

  .updates-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background: transparent;
      z-index: 2;
  }

  .cube-container {
      position: absolute;
      pointer-events: all;
      cursor: pointer;
      opacity: 0;
      transform: scale(0.8) translateY(-30px);
      transition: all 0.8s cubic-bezier(0.23, 1, 0.320, 1);
      z-index: 9999;
  }

  .cube-container.show {
      opacity: 1;
      transform: scale(1) translateY(0);
  }

  .cube-container.fade-out {
      opacity: 0;
      transform: scale(0.8) translateY(30px);
  }

  .cube-container:hover {
      transform: scale(1.08) translateY(-5px);
  }

  .cube {
    width: 110px;
    height: 110px;
    position: relative;
    transform-style: preserve-3d;
    transform: rotateX(-20deg) rotateY(35deg);
    transition: transform 0.3s ease;
  }

  .cube-face {
    position: absolute;
    width: 110px;
    height: 110px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 7px;
    font-weight: 600;
    text-align: center;
    padding: 8px;
    box-sizing: border-box;
    line-height: 1.2;
    letter-spacing: 0.2px;
    overflow: hidden;
    word-wrap: break-word;
    hyphens: auto;
    border: 1px solid rgba(0,0,0,0.1);
  }

  .front { transform: translateZ(55px); }
  .back { transform: rotateY(180deg) translateZ(55px); }
  .right { transform: rotateY(90deg) translateZ(55px); }
  .left { transform: rotateY(-90deg) translateZ(55px); }
  .top { transform: rotateX(90deg) translateZ(55px); }
  .bottom { transform: rotateX(-90deg) translateZ(55px); }

  /* Default neutral for all faces except front */
  .cube-face {
    background: #ffffff;
    color: #5a5a5a;
  }

  /* Only the FRONT face gets the vibrant color */
  .color-red .front { 
    background: #d63031; 
    color: white; 
    font-weight: 700;
  }

  .color-blue .front { 
    background: #0984e3; 
    color: white; 
    font-weight: 700;
  }

  .color-yellow .front { 
    background: #fdcb6e; 
    color: #2d3436; 
    font-weight: 700;
  }

  .color-green .front { 
    background: #00b894; 
    color: white; 
    font-weight: 700;
  }

  /* All other faces remain neutral */
  .cube-face:not(.front) {
    background: #ffffff !important;
    color: #7a7a7a !important;
  }

  .close-btn {
    position: absolute;
    top: -10px;
    right: -10px;
    background: rgba(0,0,0,0.6);
    border: none;
    color: #ffffff;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    cursor: pointer;
    font-size: 11px;
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    transition: all 0.2s ease;
  }

  .close-btn:hover {
    background: rgba(0,0,0,0.8);
    transform: scale(1.1);
  }

  .loading-indicator {
    position: fixed;
    top: 30px;
    right: 30px;
    background: rgba(44, 62, 80, 0.9);
    color: #ffffff;
    padding: 10px 15px;
    font-size: 12px;
    font-weight: 600;
    letter-spacing: 1px;
    text-transform: uppercase;
    z-index: 2000;
    opacity: 0;
    transition: all 0.3s ease;
  }

  .loading-indicator.show {
    opacity: 1;
  }

  /* Sequence number display */
  .sequence-number {
    position: absolute;
    bottom: -5px;
    left: -5px;
    background: rgba(0,0,0,0.7);
    color: white;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    font-size: 8px;
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10001;
  }
  </style>
</head>
<body>
  <svg width="100%" height="100%" xmlns="http://www.w3.org/2000/svg" style="position: absolute; top: 0; left: 0; z-index: 1; pointer-events: none;">
    <defs>
      <pattern id="isometricHangingGrid" x="0" y="0" width="120" height="104" patternUnits="userSpaceOnUse">
        <line x1="0" y1="0" x2="120" y2="0" stroke="#d0c8b8" stroke-width="0.5" opacity="0.3"/>
        <line x1="0" y1="26" x2="120" y2="26" stroke="#d0c8b8" stroke-width="0.5" opacity="0.3"/>
        <line x1="0" y1="52" x2="120" y2="52" stroke="#d0c8b8" stroke-width="0.5" opacity="0.3"/>
        <line x1="0" y1="78" x2="120" y2="78" stroke="#d0c8b8" stroke-width="0.5" opacity="0.3"/>
        <line x1="0" y1="104" x2="120" y2="104" stroke="#d0c8b8" stroke-width="0.5" opacity="0.3"/>
        
        <line x1="0" y1="104" x2="60" y2="52" stroke="#d0c8b8" stroke-width="0.5" opacity="0.3"/>
        <line x1="60" y1="104" x2="120" y2="52" stroke="#d0c8b8" stroke-width="0.5" opacity="0.3"/>
        <line x1="30" y1="104" x2="90" y2="52" stroke="#d0c8b8" stroke-width="0.5" opacity="0.3"/>
        <line x1="90" y1="104" x2="150" y2="52" stroke="#d0c8b8" stroke-width="0.5" opacity="0.3"/>
        
        <line x1="0" y1="78" x2="60" y2="26" stroke="#d0c8b8" stroke-width="0.5" opacity="0.3"/>
        <line x1="60" y1="78" x2="120" y2="26" stroke="#d0c8b8" stroke-width="0.5" opacity="0.3"/>
        <line x1="30" y1="78" x2="90" y2="26" stroke="#d0c8b8" stroke-width="0.5" opacity="0.3"/>
        
        <line x1="0" y1="52" x2="60" y2="0" stroke="#d0c8b8" stroke-width="0.5" opacity="0.3"/>
        <line x1="60" y1="52" x2="120" y2="0" stroke="#d0c8b8" stroke-width="0.5" opacity="0.3"/>
        <line x1="30" y1="52" x2="90" y2="0" stroke="#d0c8b8" stroke-width="0.5" opacity="0.3"/>
      </pattern>
    </defs>
    
    <rect width="100%" height="100%" fill="url(#isometricHangingGrid)"/>
  </svg>
  <div class="loading-indicator" id="loading-indicator">Loading Updates</div>
  <div class="updates-container" id="updates-container"></div>

  <script>
    const CHANNEL_USERNAME = "sorridianupdates";
    
    const CONFIG = {
      maxSimultaneousUpdates: 20,
      updateLifetime: 35000,
      timeBetweenUpdates: 1600,
    };

    let allUpdates = [];
    let activeCubes = [];
    let updateIndex = 0;
    let sequenceNumber = 1;
    let isLoading = false;

    // 4 color system - randomly assigned to each news
    const colors = ['color-red', 'color-blue', 'color-yellow', 'color-green'];

    // Much more horizontal cascade - spreading wide across the screen
    const cascadePath = [
      // Top row - spreading wide horizontally
      { top: '15%', left: '5%' },
      { top: '18%', left: '15%' },
      { top: '12%', left: '25%' },
      { top: '20%', left: '35%' },
      { top: '16%', left: '45%' },
      { top: '14%', left: '55%' },
      { top: '19%', left: '65%' },
      { top: '17%', left: '75%' },
      { top: '13%', left: '85%' },
      
      // Second row - wider spread
      { top: '28%', left: '8%' },
      { top: '25%', left: '18%' },
      { top: '30%', left: '28%' },
      { top: '26%', left: '38%' },
      { top: '32%', left: '48%' },
      { top: '29%', left: '58%' },
      { top: '27%', left: '68%' },
      { top: '33%', left: '78%' },
      { top: '31%', left: '88%' },
      
      // Third row - even wider
      { top: '42%', left: '3%' },
      { top: '38%', left: '13%' },
      { top: '44%', left: '23%' },
      { top: '40%', left: '33%' },
      { top: '46%', left: '43%' },
      { top: '39%', left: '53%' },
      { top: '43%', left: '63%' },
      { top: '41%', left: '73%' },
      { top: '45%', left: '83%' },
      
      // Fourth row - maximum spread
      { top: '55%', left: '6%' },
      { top: '52%', left: '16%' },
      { top: '58%', left: '26%' },
      { top: '54%', left: '36%' },
      { top: '60%', left: '46%' },
      { top: '53%', left: '56%' },
      { top: '57%', left: '66%' },
      { top: '55%', left: '76%' },
      { top: '59%', left: '86%' },
      
      // Bottom row - final spread
      { top: '68%', left: '10%' },
      { top: '65%', left: '20%' },
      { top: '72%', left: '30%' },
      { top: '69%', left: '40%' },
      { top: '74%', left: '50%' },
      { top: '67%', left: '60%' },
      { top: '71%', left: '70%' },
      { top: '70%', left: '80%' },
      
      // Additional scattered positions for even more variety
      { top: '22%', left: '12%' },
      { top: '24%', left: '22%' },
      { top: '21%', left: '32%' },
      { top: '23%', left: '42%' },
      { top: '25%', left: '52%' },
      { top: '22%', left: '62%' },
      { top: '24%', left: '72%' },
      { top: '20%', left: '82%' },
      
      { top: '36%', left: '10%' },
      { top: '34%', left: '20%' },
      { top: '37%', left: '30%' },
      { top: '35%', left: '40%' },
      { top: '38%', left: '50%' },
      { top: '36%', left: '60%' },
      { top: '35%', left: '70%' },
      { top: '37%', left: '80%' },
      
      { top: '49%', left: '8%' },
      { top: '47%', left: '18%' },
      { top: '51%', left: '28%' },
      { top: '48%', left: '38%' },
      { top: '50%', left: '48%' },
      { top: '49%', left: '58%' },
      { top: '47%', left: '68%' },
      { top: '51%', left: '78%' },
      
      { top: '62%', left: '5%' },
      { top: '64%', left: '15%' },
      { top: '61%', left: '25%' },
      { top: '63%', left: '35%' },
      { top: '60%', left: '45%' },
      { top: '62%', left: '55%' },
      { top: '64%', left: '65%' },
      { top: '61%', left: '75%' },
      { top: '63%', left: '85%' }
    ];

    let currentPathIndex = 0;

    function showLoading() {
      isLoading = true;
      document.getElementById('loading-indicator').classList.add('show');
    }

    function hideLoading() {
      isLoading = false;
      document.getElementById('loading-indicator').classList.remove('show');
    }

    function getNextPosition() {
      // Get next position in cascade, with slight randomization
      const basePosition = cascadePath[currentPathIndex % cascadePath.length];
      currentPathIndex++;
      
      // Add slight random variation to make it more organic
      const variation = 2; // smaller variation for more controlled spread
      const randomTop = parseFloat(basePosition.top) + (Math.random() - 0.5) * variation;
      const randomLeft = parseFloat(basePosition.left) + (Math.random() - 0.5) * variation;
      
      return {
        top: Math.max(8, Math.min(80, randomTop)) + '%',
        left: Math.max(2, Math.min(92, randomLeft)) + '%'
      };
    }

    function createCube(update, position) {
      const container = document.createElement('div');
      
      // Randomly assign one of the 4 colors
      const colorClass = colors[Math.floor(Math.random() * colors.length)];
      
      container.className = `cube-container ${colorClass}`;
      container.style.zIndex = '9999';
      container.style.top = position.top;
      container.style.left = position.left;

      const content = update.text.length > 25 ? 
        update.text.substring(0, 22) + '...' : 
        update.text;

      container.innerHTML = `
        <button class="close-btn" onclick="removeCube(this.parentElement)">Ã—</button>
        <div class="sequence-number">${sequenceNumber}</div>
        <div class="cube">
          <div class="cube-face front">${content}</div>
          <div class="cube-face back"></div>
          <div class="cube-face right"></div>
          <div class="cube-face left"></div>
          <div class="cube-face top"></div>
          <div class="cube-face bottom"></div>
        </div>
      `;

      document.getElementById('updates-container').appendChild(container);

      setTimeout(() => {
          container.classList.add('show');
      }, 100);

      const removeTimeout = setTimeout(() => {
        removeCube(container);
      }, CONFIG.updateLifetime);

      const cubeData = {
        element: container,
        position: position,
        timeout: removeTimeout,
        sequenceNumber: sequenceNumber
      };
      
      activeCubes.push(cubeData);
      sequenceNumber++;
      
      return cubeData;
    }

    function removeCube(cubeElement) {
      const cubeData = activeCubes.find(c => c.element === cubeElement);
      if (!cubeData) return;

      clearTimeout(cubeData.timeout);
      activeCubes = activeCubes.filter(c => c !== cubeData);

      cubeElement.classList.add('fade-out');
      
      setTimeout(() => {
        if (cubeElement.parentElement) {
          cubeElement.parentElement.removeChild(cubeElement);
        }
      }, 800);
    }

    function showNextCube() {
      if (isLoading || allUpdates.length === 0 || activeCubes.length >= CONFIG.maxSimultaneousUpdates) {
        return;
      }
      
      const update = allUpdates[updateIndex % allUpdates.length];
      updateIndex++;
      
      const position = getNextPosition();
      createCube(update, position);
    }

    async function fetchTelegramPosts() {
      try {
        showLoading();
        const proxies = [
          'https://api.allorigins.win/raw?url=',
          'https://cors-anywhere.herokuapp.com/',
          'https://corsproxy.io/?'
        ];
        
        const telegramPublicUrl = `https://t.me/s/${CHANNEL_USERNAME}`;
        let html = null;
        
        for (const proxy of proxies) {
          try {
            const finalUrl = proxy.includes('?url=') 
              ? proxy + encodeURIComponent(telegramPublicUrl)
              : proxy + telegramPublicUrl;
              
            const response = await fetch(finalUrl);
            
            if (response.ok) {
              html = await response.text();
              break;
            }
          } catch (proxyError) {}
        }
        
        if (!html) {
          throw new Error("All proxies failed");
        }
        
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        const selectors = [
          '.tgme_widget_message_text', 
          '.tgme_widget_message_bubble', 
          '.js-message_text'
        ];
        
        let messageElements = [];
        
        for (const selector of selectors) {
          const elements = doc.querySelectorAll(selector);
          if (elements && elements.length > 0) {
            messageElements = elements;
            break;
          }
        }
        
        if (messageElements.length > 0) {
          const messages = Array.from(messageElements)
            .map(element => ({ text: element.textContent.trim() }))
            .filter(msg => {
              if (!msg.text) return false;
              
              const adminMessages = [
                "channel created", "invited by", "joined the channel",
                "changed the channel", "changed channel", "pinned a message",
                "changed the chat photo", "changed the group photo",
                "the group was renamed", "the channel was renamed",
                "changed group name", "changed channel name",
                "added a new admin", "removed an admin",
                "added admin", "removed admin",
                "created the group", "created the channel"
              ];
              const lowerCaseText = msg.text.toLowerCase();
              return !adminMessages.some(phrase => lowerCaseText.includes(phrase.toLowerCase()));
            })
            .slice(0, 15);
          
          if (messages.length > 0) {
            allUpdates = messages;
          } else {
            allUpdates = [
              { text: "News spreading wide..." },
              { text: "Follow @" + CHANNEL_USERNAME },
              { text: "Updates flowing across" },
              { text: "Wide village stories" },
              { text: "Horizon of information" },
              { text: "Landscape of news" },
              { text: "Spreading updates" }
            ];
          }
        } else {
          allUpdates = [
            { text: "News spreading wide..." },
            { text: "Follow @" + CHANNEL_USERNAME },
            { text: "Updates flowing across" },
            { text: "Wide village stories" },
            { text: "Horizon of information" }
          ];
        }
        
        hideLoading();
      } catch (error) {
        allUpdates = [
          { text: "News cascading wide..." },
          { text: "Stories across horizon" },
          { text: "Follow @" + CHANNEL_USERNAME },
          { text: "Wide updates coming" }
        ];
        hideLoading();
      }
    }

    function startCubeDisplay() {
      if (allUpdates.length > 0) {
        showNextCube();
      }
      setInterval(showNextCube, CONFIG.timeBetweenUpdates);
    }

    window.removeCube = removeCube;

    async function init() {
      await fetchTelegramPosts();
      startCubeDisplay();
      setInterval(fetchTelegramPosts, 300000);
    }

    init();
  </script>
</body>
</html>